package com.depromeet.breadmapbackend.domain.bakery.ranking;

import static org.assertj.core.api.Assertions.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.util.Assert;

import com.depromeet.breadmapbackend.domain.bakery.Bakery;
import com.depromeet.breadmapbackend.domain.bakery.BakeryStatus;

import lombok.Builder;
import lombok.Getter;

/**
 * BakeryRankTest
 *
 * @author jaypark
 * @version 1.0.0
 * @since 2023/07/02
 */
class ScoredBakeryTest {

	private ScoredBakeryService sut;

	@BeforeEach
	void setUp() {
		final ScoredBakeryRepository repository = new ScoredBakeryRepositoryImpl();
		sut = new ScoredBakeryServiceImpl(repository);
	}

	@Test
	void BakeryScores_가중치에_따라_점수를_계산하여_ScoredBakery를_생성할_수_있다() throws Exception {
		//given
		final Bakery bakery = Bakery.builder()
			.address("수원시 영통구 삼성로 111")
			.latitude(37.5596080725671)
			.longitude(127.044235133983)
			.name("bakery")
			.status(BakeryStatus.POSTING)
			.image("bakeryImage.jpg")
			.build();
		final double bakeryRating = 4.5;
		final Long flagCount = 2L;

		final double expectedTotalScore = 6.5;
		final BakeryScores bakeryScores = new BakeryScores(bakery, bakeryRating, flagCount);
		//when
		final ScoredBakery result = ScoredBakery.from(bakeryScores);
		//then
		assertThat(result.getTotalScore()).isEqualTo(expectedTotalScore);

	}

	@Test
	void bakery랭킹_등록() throws Exception {
		//given
		final Bakery bakery = Bakery.builder()
			.address("수원시 영통구 삼성로 111")
			.latitude(37.5596080725671)
			.longitude(127.044235133983)
			.name("bakery")
			.status(BakeryStatus.POSTING)
			.image("bakeryImage.jpg")
			.build();
		final double bakeryRating = 4.5;
		final Long reviewCount = 10L;
		final Long flagCount = 2L;
		final BakeryScores bakeryScores = new BakeryScores(bakery, bakeryRating, flagCount);

		//when
		final int insertedCount = sut.registerBakeriesRank(List.of(bakeryScores));

		//then
		assertThat(insertedCount).isEqualTo(1);

	}

	private interface ScoredBakeryService {
		int registerBakeriesRank(List<BakeryScores> bakeriesScores);
	}

	private class ScoredBakeryServiceImpl implements ScoredBakeryService {

		private final ScoredBakeryRepository scoredBakeryRepository;

		private ScoredBakeryServiceImpl(final ScoredBakeryRepository scoredBakeryRepository) {
			this.scoredBakeryRepository = scoredBakeryRepository;
		}

		public int registerBakeriesRank(final List<BakeryScores> bakeriesScores) {
			final List<ScoredBakery> scoredBakeryList = bakeriesScores.stream()
				.map(ScoredBakery::from).toList();

			return scoredBakeryRepository.bulkInsert(scoredBakeryList);
		}
	}

	private record BakeryScores(
		Bakery bakery,
		double bakeryRating,
		Long flagCount
	) {

	}

	@Getter
	public static class ScoredBakery {

		private final Long id;
		private final Bakery bakery;
		private final double bakeryRating;
		private final Long flagCount;
		private final double totalScore;

		@Builder
		private ScoredBakery(final Long id, final Bakery bakery, final double bakeryRating,
			final Long flagCount, final double totalScore) {

			Assert.notNull(bakery, "bakery must not be null");
			Assert.isTrue(bakeryRating >= 0 && bakeryRating <= 5, "bakeryRating must be between 0 and 5");
			Assert.notNull(flagCount, "flagCount must not be null");

			this.id = id;
			this.bakery = bakery;
			this.bakeryRating = bakeryRating;
			this.flagCount = flagCount;
			this.totalScore = totalScore;
		}

		private static ScoredBakery from(final BakeryScores bakeryScores) {
			return ScoredBakery.builder()
				.bakery(bakeryScores.bakery)
				.bakeryRating(bakeryScores.bakeryRating)
				.flagCount(bakeryScores.flagCount)
				.totalScore(calculateTotalScore(bakeryScores.bakeryRating, bakeryScores.flagCount))
				.build();
		}

		private static double calculateTotalScore(final double bakeryRating, final Long flagCount) {
			return (bakeryRating * RankWeight.RATING_WEIGHT.getWeight()) +
				(flagCount.doubleValue() * RankWeight.FLAG_COUNT_WEIGHT.getWeight());
		}
	}

	private class ScoredBakeryRepositoryImpl implements ScoredBakeryRepository {

		private final AtomicLong autoGeneratedId = new AtomicLong(0);
		private final List<ScoredBakery> data = Collections.synchronizedList(new ArrayList<>());

		@Override
		public int bulkInsert(final List<ScoredBakery> scoredBakeryList) {
			data.clear();
			scoredBakeryList.stream()
				.map(scoredBakery -> ScoredBakery.builder()
					.id(autoGeneratedId.incrementAndGet())
					.bakery(scoredBakery.getBakery())
					.bakeryRating(scoredBakery.getBakeryRating())
					.flagCount(scoredBakery.getFlagCount())
					.totalScore(scoredBakery.getTotalScore())
					.build())
				.forEach(data::add);

			return data.size();
		}
	}

	private interface ScoredBakeryRepository {
		int bulkInsert(final List<ScoredBakery> scoredBakeryList);
	}
}